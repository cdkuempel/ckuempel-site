---
title: Gene trees to allele trees
author: Joel Nitta
date: '2018-07-09'
slug: gene-trees-to-allele-trees
summary: Making species complexes a *little* bit easier to understand
categories: [R]
tags: [R]
header:
  caption: ''
  image: ''
draft: TRUE
---

Interpreting phylogenetic trees is fairly straightforward when there is a one-to-one relationship between the tips of the tree and the source of the sequences. This is typically the case for datasets where the sequences are from chloroplast or mitochondrial genes, so there is only a single copy per individual. 

However, things aren't so neat when you're dealing with nuclear genes of polyploids and hybrids (as often occur in ferns)! These may harbor multiple sequence copies in each individual, and may share identical copies across different individuals. In such cases, a "normal" phylogenetic tree (what I'll call the "gene tree") can be downright confusing. It can be easier to instead identify all the unique sequences in the alignment (here, I'll call these "alleles"), and infer a tree of these alleles (the "allele tree"). We would then look at this in tandem with a table showing which individual possesses which allele(s). 

I recently came across just this case in my research, but I wasn't aware of any script to automate going from gene trees to allele trees. Doing this sort of thing by hand is tempting fate and awkward to do everytime we get new data, so I wrote an R script to do it. Let's see how!

First, generate some toy data using `phytools`.

```{r make_data, message = FALSE, results = "hide"}
library(phytools)

# For reproducibility
set.seed(123)

# Simulate a tree with 10 species and some DNA sequence data
phy <- pbtree(n=10, tip.label=paste0("Sp_", LETTERS[1:10]))
gg <- rgamma(n=100, shape=0.25, rate=0.25)
alignment <- genSeq(phy, l=100, rate=gg)
```

Let's have a look at our simulated data. This is what a "normal" tree might look like:

```{r view_basic_data}
# Make the tree prettier for plotting
phy <- ladderize(phy, right = FALSE)

# View the tree
plot (phy)
```

Now we'll tweak the dataset a bit to reflect what a polyploid dataset might look like

```{r make_polyploid_data}
# First let's add 5 more "species" to the alignment
more_species <- alignment[sample(nrow(alignment), 5, replace = TRUE), ]
rownames(more_species) <- paste0("Sp_", LETTERS[11:15])
alignment <- rbind(alignment, more_species)

# Randomly resample some of the alignment and scramble the names
more_data <- alignment[sample(nrow(alignment), 10), ]
rownames(more_data) <- sample(rownames(more_data), 10)

# Now each species can have multiple sequences.
# We'll call these "seq_1" and "seq_2"
rownames(alignment) <- paste0(rownames(alignment), "_seq_1")
rownames(more_data) <- paste0(rownames(more_data), "_seq_2")

# Combine the two datasets
alignment <- rbind(alignment, more_data)

# Make a quick neighbor-joining tree
phy <- nj(dist.dna(alignment))

# Ladderize and view the tree
phy <- ladderize(phy, right = FALSE)
plot (phy)
```

Ugh. See what I mean? Deducing which species have multiple alleles and where they are on the tree requires a lot of squinting. Let's work on making this an "haplotype tree".

Start by identifying groups of identical sequences and collapsing them into haplotypes. Note that the use of `seqinr::consensus` is redudant here since sequences separated by distance of zero in our toy data are identical. However, this is not the case in real-life, when zero-distance sequences may actually differ by insertion/deletion mutations (indels) or sequence length.

```{r collapse_alleles}
library(seqinr)
library(tidyverse)
map <- purrr::map

# Calculate distances (note confusing pairwise deletion
# setting - if set to FALSE, it *does* delete all gaps)
distances <- dist.dna(alignment, pairwise.deletion = TRUE, 
                      model="raw", as.matrix=FALSE)
  
# Get groups of identical sequences
# (those with zero distance separating theme)
haplotype_groups <- cutree(hclust(distances), h=0)
  
# Split alignment up by these groups
split_alignments <- split(alignment, haplotype_groups)
  
# Calculate consensus of each alignment; 
# these are the haplotypes
haplotypes <- map(split_alignments, ~ 
                   seqinr::consensus(
                     as.character(as.matrix(.x)), 
                     method = "majority"))
  
# Convert list of haplotypes back into DNA alignment
#haplotypes <- dplyr::bind_rows(haplotypes)
#haplotypes <- t(haplotypes)
#haplotypes <- as.DNAbin(haplotypes)

```


```{r collapse_alleles_2}
library(pegas)
library(tidyverse)

haplotype(alignment)

```

Note that `pegas::haplotype` does something very similar. However, it's not clear to me how it handles missing data. By using `ape::dist.dna` and `seqinr::consensus` above, we have more control over how to call haplotypes.

